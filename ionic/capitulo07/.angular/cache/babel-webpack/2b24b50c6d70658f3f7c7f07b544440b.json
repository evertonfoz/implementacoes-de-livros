{"ast":null,"code":"import _asyncToGenerator from \"X:/capitulo07/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Deferred } from '@firebase/util';\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\n\nclass Component {\n  /**\r\n   *\r\n   * @param name The public service name, e.g. app, auth, firestore, database\r\n   * @param instanceFactory Service factory responsible for creating the public interface\r\n   * @param type whether the service provided by the component is public or private\r\n   */\n  constructor(name, instanceFactory, type) {\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\r\n     * Properties to be added to the service namespace\r\n     */\n\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\"\n    /* LAZY */\n    ;\n    this.onInstanceCreated = null;\n  }\n\n  setInstantiationMode(mode) {\n    this.instantiationMode = mode;\n    return this;\n  }\n\n  setMultipleInstances(multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  }\n\n  setServiceProps(props) {\n    this.serviceProps = props;\n    return this;\n  }\n\n  setInstanceCreatedCallback(callback) {\n    this.onInstanceCreated = callback;\n    return this;\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\n\nclass Provider {\n  constructor(name, container) {\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n    this.instancesOptions = new Map();\n    this.onInitCallbacks = new Map();\n  }\n  /**\r\n   * @param identifier A provider can provide mulitple instances of a service\r\n   * if this.component.multipleInstances is true.\r\n   */\n\n\n  get(identifier) {\n    // if multipleInstances is not supported, use the default name\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      const deferred = new Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        // initialize the service if it can be auto-initialized\n        try {\n          const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {// when the instance factory throws an exception during get(), it should not cause\n          // a fatal error. We just return the unresolved promise in this case.\n        }\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  }\n\n  getImmediate(options) {\n    var _a; // if multipleInstances is not supported, use the default name\n\n\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n    const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n      if (optional) {\n        return null;\n      } else {\n        throw Error(`Service ${this.name} is not available`);\n      }\n    }\n  }\n\n  getComponent() {\n    return this.component;\n  }\n\n  setComponent(component) {\n    if (component.name !== this.name) {\n      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n    }\n\n    if (this.component) {\n      throw Error(`Component for ${this.name} has already been provided`);\n    }\n\n    this.component = component; // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n\n    if (!this.shouldAutoInitialize()) {\n      return;\n    } // if the service is eager, initialize the default instance\n\n\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({\n          instanceIdentifier: DEFAULT_ENTRY_NAME\n        });\n      } catch (e) {// when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    } // Create service instances for the pending promises and resolve them\n    // NOTE: if this.multipleInstances is false, only the default instance will be created\n    // and all promises with resolve with it regardless of the identifier.\n\n\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n      try {\n        // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n        const instance = this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n        instanceDeferred.resolve(instance);\n      } catch (e) {// when the instance factory throws an exception, it should not cause\n        // a fatal error. We just leave the promise unresolved.\n      }\n    }\n  }\n\n  clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  } // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n\n\n  delete() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const services = Array.from(_this.instances.values());\n      yield Promise.all([...services.filter(service => 'INTERNAL' in service) // legacy services\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .map(service => service.INTERNAL.delete()), ...services.filter(service => '_delete' in service) // modularized services\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .map(service => service._delete())]);\n    })();\n  }\n\n  isComponentSet() {\n    return this.component != null;\n  }\n\n  isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instances.has(identifier);\n  }\n\n  getOptions(identifier = DEFAULT_ENTRY_NAME) {\n    return this.instancesOptions.get(identifier) || {};\n  }\n\n  initialize(opts = {}) {\n    const {\n      options = {}\n    } = opts;\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n    }\n\n    if (!this.isComponentSet()) {\n      throw Error(`Component ${this.name} has not been registered yet`);\n    }\n\n    const instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options\n    }); // resolve any pending promise waiting for the service instance\n\n    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n      if (normalizedIdentifier === normalizedDeferredIdentifier) {\n        instanceDeferred.resolve(instance);\n      }\n    }\n\n    return instance;\n  }\n  /**\r\n   *\r\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n   *\r\n   * @param identifier An optional instance identifier\r\n   * @returns a function to unregister the callback\r\n   */\n\n\n  onInit(callback, identifier) {\n    var _a;\n\n    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n    const existingInstance = this.instances.get(normalizedIdentifier);\n\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n\n    return () => {\n      existingCallbacks.delete(callback);\n    };\n  }\n  /**\r\n   * Invoke onInit callbacks synchronously\r\n   * @param instance the service instance`\r\n   */\n\n\n  invokeOnInitCallbacks(instance, identifier) {\n    const callbacks = this.onInitCallbacks.get(identifier);\n\n    if (!callbacks) {\n      return;\n    }\n\n    for (const callback of callbacks) {\n      try {\n        callback(instance, identifier);\n      } catch (_a) {// ignore errors in the onInit callback\n      }\n    }\n  }\n\n  getOrInitializeService({\n    instanceIdentifier,\n    options = {}\n  }) {\n    let instance = this.instances.get(instanceIdentifier);\n\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n      /**\r\n       * Invoke onInit listeners.\r\n       * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n       * while onInit listeners are registered by consumers of the provider.\r\n       */\n\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n      /**\r\n       * Order is important\r\n       * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n       * makes `isInitialized()` return true.\r\n       */\n\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n        } catch (_a) {// ignore errors in the onInstanceCreatedCallback\n        }\n      }\n    }\n\n    return instance || null;\n  }\n\n  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  }\n\n  shouldAutoInitialize() {\n    return !!this.component && this.component.instantiationMode !== \"EXPLICIT\"\n    /* EXPLICIT */\n    ;\n  }\n\n} // undefined should be passed to the service factory for the default instance\n\n\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\n\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\"\n  /* EAGER */\n  ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\n\n\nclass ComponentContainer {\n  constructor(name) {\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\r\n   *\r\n   * @param component Component being added\r\n   * @param overwrite When a component with the same name has already been registered,\r\n   * if overwrite is true: overwrite the existing component with the new component and create a new\r\n   * provider with the new component. It can be useful in tests where you want to use different mocks\r\n   * for different tests.\r\n   * if overwrite is false: throw an exception\r\n   */\n\n\n  addComponent(component) {\n    const provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n    }\n\n    provider.setComponent(component);\n  }\n\n  addOrOverwriteComponent(component) {\n    const provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n\n    this.addComponent(component);\n  }\n  /**\r\n   * getProvider provides a type safe interface where it can only be called with a field name\r\n   * present in NameServiceMapping interface.\r\n   *\r\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n   * themselves.\r\n   */\n\n\n  getProvider(name) {\n    if (this.providers.has(name)) {\n      return this.providers.get(name);\n    } // create a Provider for a service that hasn't registered with Firebase\n\n\n    const provider = new Provider(name, this);\n    this.providers.set(name, provider);\n    return provider;\n  }\n\n  getProviders() {\n    return Array.from(this.providers.values());\n  }\n\n}\n\nexport { Component, ComponentContainer, Provider };","map":{"version":3,"sources":["X:/capitulo07/node_modules/@firebase/component/dist/esm/index.esm2017.js"],"names":["Deferred","Component","constructor","name","instanceFactory","type","multipleInstances","serviceProps","instantiationMode","onInstanceCreated","setInstantiationMode","mode","setMultipleInstances","setServiceProps","props","setInstanceCreatedCallback","callback","DEFAULT_ENTRY_NAME","Provider","container","component","instances","Map","instancesDeferred","instancesOptions","onInitCallbacks","get","identifier","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","set","isInitialized","shouldAutoInitialize","instance","getOrInitializeService","instanceIdentifier","resolve","e","promise","getImmediate","options","_a","optional","Error","getComponent","setComponent","isComponentEager","instanceDeferred","entries","clearInstance","delete","services","Array","from","values","Promise","all","filter","service","map","INTERNAL","_delete","isComponentSet","getOptions","initialize","opts","normalizedDeferredIdentifier","onInit","existingCallbacks","Set","add","existingInstance","invokeOnInitCallbacks","callbacks","normalizeIdentifierForFactory","undefined","ComponentContainer","providers","addComponent","provider","getProvider","addOrOverwriteComponent","getProviders"],"mappings":"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","sourcesContent":["import { Deferred } from '@firebase/util';\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass Component {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    constructor(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    setInstantiationMode(mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    }\r\n    setMultipleInstances(multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    }\r\n    setServiceProps(props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    }\r\n    setInstanceCreatedCallback(callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nclass Provider {\r\n    constructor(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    get(identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            const deferred = new Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    const instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    }\r\n    getImmediate(options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(`Service ${this.name} is not available`);\r\n            }\r\n        }\r\n    }\r\n    getComponent() {\r\n        return this.component;\r\n    }\r\n    setComponent(component) {\r\n        if (component.name !== this.name) {\r\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\r\n        }\r\n        if (this.component) {\r\n            throw Error(`Component for ${this.name} has already been provided`);\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        // Create service instances for the pending promises and resolve them\r\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n        // and all promises with resolve with it regardless of the identifier.\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            try {\r\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                const instance = this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception, it should not cause\r\n                // a fatal error. We just leave the promise unresolved.\r\n            }\r\n        }\r\n    }\r\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    }\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    async delete() {\r\n        const services = Array.from(this.instances.values());\r\n        await Promise.all([\r\n            ...services\r\n                .filter(service => 'INTERNAL' in service) // legacy services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service.INTERNAL.delete()),\r\n            ...services\r\n                .filter(service => '_delete' in service) // modularized services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service._delete())\r\n        ]);\r\n    }\r\n    isComponentSet() {\r\n        return this.component != null;\r\n    }\r\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instances.has(identifier);\r\n    }\r\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instancesOptions.get(identifier) || {};\r\n    }\r\n    initialize(opts = {}) {\r\n        const { options = {} } = opts;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(`Component ${this.name} has not been registered yet`);\r\n        }\r\n        const instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options\r\n        });\r\n        // resolve any pending promise waiting for the service instance\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    onInit(callback, identifier) {\r\n        var _a;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        const existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return () => {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    }\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    invokeOnInitCallbacks(instance, identifier) {\r\n        const callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        for (const callback of callbacks) {\r\n            try {\r\n                callback(instance, identifier);\r\n            }\r\n            catch (_a) {\r\n                // ignore errors in the onInit callback\r\n            }\r\n        }\r\n    }\r\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\r\n        let instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_a) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    }\r\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    }\r\n    shouldAutoInitialize() {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* EXPLICIT */);\r\n    }\r\n}\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass ComponentContainer {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    addComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\r\n        }\r\n        provider.setComponent(component);\r\n    }\r\n    addOrOverwriteComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    }\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    getProvider(name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        const provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    }\r\n    getProviders() {\r\n        return Array.from(this.providers.values());\r\n    }\r\n}\n\nexport { Component, ComponentContainer, Provider };\n"]},"metadata":{},"sourceType":"module"}